package de.codesourcery.voxelengine.blockeditor;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.geom.AffineTransform;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.OutputStream;

import javax.imageio.ImageIO;

public class TextureAtlasBuilder 
{
    // size of border around each texture
    public int textureBorderSize = 1;
    
    public void build(BlockConfig config,TextureResolver resolver,OutputStream out) throws IOException 
    {
        ImageIO.write( build( config , resolver , false ) , "png" , out );
    }
    
    public BufferedImage build(BlockConfig config,TextureResolver resolver,boolean onlyAssignTextureCoordinates) throws IOException
    {
            // TODO: BufferedImage_TYPE_INT_ARGB assumes pre-multiplied alpha...
           final BufferedImage atlas = onlyAssignTextureCoordinates ? null : new BufferedImage( config.textureAtlasSize , config.textureAtlasSize , BufferedImage.TYPE_INT_RGB );
           
           final int atlasW = config.textureAtlasSize;
           final int atlasH = config.textureAtlasSize;
           
           final Graphics2D graphics = onlyAssignTextureCoordinates ? null : atlas.createGraphics();
           
           if ( ! onlyAssignTextureCoordinates ) {
               graphics.setColor( Color.WHITE );
               graphics.fillRect( 0 , 0 , atlasW , atlasH );
           }
           int x0 = textureBorderSize;
           int y0 = textureBorderSize;
           
           final boolean yOriginAtBottom = false;
           
           for ( BlockDefinition blockDef : config.blocks ) 
           {
               if ( blockDef.isAutoGenerated() ) {
                   continue;
               }
               for ( BlockSideDefinition sideDef : blockDef.sides ) 
               {
                   if ( ! sideDef.isTextureAssigned() ) {
                       continue;
                   }
                   
                   BufferedImage texture = resolver.resolve( sideDef.getInputTexture() );
                   
                   if ( (x0+config.blockTextureSize+textureBorderSize) >= atlasW ) 
                   {
                       x0 = textureBorderSize;
                       y0 += config.blockTextureSize+textureBorderSize;
                       
                       if ( (y0+config.blockTextureSize+textureBorderSize) >= atlasH) {
                           throw new IOException("Atlas size exceeded - texture "+sideDef+" does not fit");
                       }
                       
                       if ( (x0+config.blockTextureSize+textureBorderSize) >= atlasW) {
                           throw new IOException("Atlas size exceeded - texture "+sideDef+" does not fit");
                       }
                   }
                   
                   final int x1 = x0 + config.blockTextureSize;
                   final int y1 = y0 + config.blockTextureSize;                   
                   
                   if ( ! onlyAssignTextureCoordinates ) 
                   {
                       if ( texture.getWidth() != config.blockTextureSize || texture.getHeight() != config.blockTextureSize ) 
                       {
                           double sx,sy;
                           if ( texture.getWidth() > texture.getHeight() ) 
                           {
                               sx = config.blockTextureSize / (double) texture.getWidth();
                               sy = sx;
                           } else {
                               sy = config.blockTextureSize / (double) texture.getHeight();
                               sx = sy;
                           }
                           final AffineTransform tx = AffineTransform.getScaleInstance(sx,sy);
                           final AffineTransformOp op = new AffineTransformOp(tx, AffineTransformOp.TYPE_BICUBIC);
                           texture = op.filter(texture, null);
                       }
                       graphics.drawImage( texture , x0 , y0 , null );
                   }
                   
                   final float u0 = x0 / (float) atlasW;
                   final float v0;
                   if ( yOriginAtBottom ) {
                       v0 = (atlasH-y0) /(float) atlasH; // (u,v) origin is bottom left corner in OpenGL
                   } else {
                       v0 = y0 / (float) atlasH; 
                   }
                   
                   final float u1 = x1 / (float) atlasW;
                   final float v1;
                   if ( yOriginAtBottom ) {
                       v1 = (atlasH-y1) / (float) atlasH; // (u,v) origin is bottom left corner in OpenGL
                   } else {
                       v1 = y1 / (float) atlasH; 
                   }

                   if ( u0 < 0 || v0 < 0 || u1 < 0 || v1 < 0 || u0 > 1 || v0 > 1 || u1 > 1 || v1 > 1 ) {
                       throw new RuntimeException("Internal error");
                   }
                   
                   System.out.println("("+x0+","+y0+") => ("+u0+" , "+v0+" )");
                   System.out.println("("+x1+","+y1+") => ("+u1+" , "+v1+" )");

                   sideDef.u0 = u0;
                   sideDef.v0 = v0;
                   sideDef.u1 = u1;
                   sideDef.v1 = v1;
                   
                   x0 += config.blockTextureSize+textureBorderSize;
               }
           }
           return atlas;
    }
}