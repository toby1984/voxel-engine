package de.codesourcery.voxelengine.asseteditor;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.geom.AffineTransform;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.List;

import javax.imageio.ImageIO;

public class TextureAtlasBuilder 
{
    // size of border around each texture
    public int textureBorderSize = 1;

    public BufferedImage buildBlockTextureAtlas(AssetConfig config,TextureResolver resolver,OutputStream out) throws IOException 
    {
        return buildBlockTextureAtlas(config,resolver,out,false);
    }
    
    private BufferedImage buildBlockTextureAtlas(AssetConfig config,TextureResolver resolver,OutputStream out,boolean onlyAssignTextureCoordinates) throws IOException 
    {
        // output atlas for block textures
        final List<TextureConfig> textures = new ArrayList<>();
        for ( BlockDefinition blockDef : config.blocks ) 
        {
            if ( blockDef.isAutoGenerated() ) {
                continue;
            }
            for ( BlockSideDefinition sideDef : blockDef.sides ) 
            {
                if ( ! sideDef.isTextureAssigned() ) {
                    continue;
                }
                textures.add( sideDef.texture );
            }
        }

        final BufferedImage image = build( config.blockAtlas() , textures , resolver , false );
        if ( ! onlyAssignTextureCoordinates && out != null )
        {
            ImageIO.write( image , "png" , out );
        }
        return image;
    }
    
    public BufferedImage buildItemTextureAtlas(AssetConfig config,TextureResolver resolver,OutputStream out) throws IOException 
    {
        return buildItemTextureAtlas(config,resolver,out,false);
    }
    
    private BufferedImage buildItemTextureAtlas(AssetConfig config,TextureResolver resolver,OutputStream out,boolean onlyAssignTextureCoordinates) throws IOException 
    {
        // output atlas for block textures
        final List<TextureConfig> textures = new ArrayList<>();
        for ( ItemDefinition item : config.items ) 
        {
            textures.add( item.texture );
        }
        final BufferedImage image = build( config.itemAtlas() , textures , resolver , onlyAssignTextureCoordinates );
        if ( ! onlyAssignTextureCoordinates && out != null ) {
            ImageIO.write( image , "png" , out );
        }
        return image;
    }    
    
    public void assignTextureCoordinates(AssetConfig config,TextureResolver resolver) throws IOException 
    {
        buildBlockTextureAtlas(config,resolver,null,true);
        buildItemTextureAtlas(config,resolver,null,true);
    }

    private BufferedImage build(TextureAtlasConfig config,List<TextureConfig> textures,TextureResolver resolver,boolean onlyAssignTextureCoordinates) throws IOException
    {
        // TODO: BufferedImage_TYPE_INT_ARGB assumes pre-multiplied alpha...
        final BufferedImage atlas = onlyAssignTextureCoordinates ? null : new BufferedImage( config.textureAtlasSize , config.textureAtlasSize , BufferedImage.TYPE_INT_ARGB );

        final int atlasW = config.textureAtlasSize;
        final int atlasH = config.textureAtlasSize;

        final Graphics2D graphics = onlyAssignTextureCoordinates ? null : atlas.createGraphics();

        if ( ! onlyAssignTextureCoordinates ) {
            graphics.setColor( Color.WHITE );
            graphics.fillRect( 0 , 0 , atlasW , atlasH );
        }
        int x0 = textureBorderSize;
        int y0 = textureBorderSize;

        final boolean yOriginAtBottom = false;

        for ( TextureConfig tex : textures )
        {
            BufferedImage texture = resolver.resolve( tex.getInputTexture() );

            if ( (x0+config.textureSize+textureBorderSize) >= atlasW ) 
            {
                x0 = textureBorderSize;
                y0 += config.textureSize+textureBorderSize;

                if ( (y0+config.textureSize+textureBorderSize) >= atlasH) {
                    throw new IOException("Atlas size exceeded - texture "+tex+" does not fit");
                }

                if ( (x0+config.textureSize+textureBorderSize) >= atlasW) {
                    throw new IOException("Atlas size exceeded - texture "+tex+" does not fit");
                }
            }

            final int x1 = x0 + config.textureSize;
            final int y1 = y0 + config.textureSize;                   

            if ( ! onlyAssignTextureCoordinates ) 
            {
                if ( texture.getWidth() != config.textureSize || texture.getHeight() != config.textureSize ) 
                {
                    double sx,sy;
                    if ( texture.getWidth() > texture.getHeight() ) 
                    {
                        sx = config.textureSize / (double) texture.getWidth();
                        sy = sx;
                    } else {
                        sy = config.textureSize / (double) texture.getHeight();
                        sx = sy;
                    }
                    final AffineTransform tx = AffineTransform.getScaleInstance(sx,sy);
                    final AffineTransformOp op = new AffineTransformOp(tx, AffineTransformOp.TYPE_BICUBIC);
                    texture = op.filter(texture, null);
                }
                graphics.drawImage( texture , x0 , y0 , null );
            }

            final float u0 = x0 / (float) atlasW;
            final float v0;
            if ( yOriginAtBottom ) {
                v0 = (atlasH-y0) /(float) atlasH; // (u,v) origin is bottom left corner in OpenGL
            } else {
                v0 = y0 / (float) atlasH; 
            }

            final float u1 = x1 / (float) atlasW;
            final float v1;
            if ( yOriginAtBottom ) {
                v1 = (atlasH-y1) / (float) atlasH; // (u,v) origin is bottom left corner in OpenGL
            } else {
                v1 = y1 / (float) atlasH; 
            }

            if ( u0 < 0 || v0 < 0 || u1 < 0 || v1 < 0 || u0 > 1 || v0 > 1 || u1 > 1 || v1 > 1 ) {
                throw new RuntimeException("Internal error");
            }

            System.out.println("("+x0+","+y0+") => ("+u0+" , "+v0+" )");
            System.out.println("("+x1+","+y1+") => ("+u1+" , "+v1+" )");

            tex.u0 = u0;
            tex.v0 = v0;
            tex.u1 = u1;
            tex.v1 = v1;

            x0 += config.textureSize+textureBorderSize;
        }
        return atlas;
    }
}